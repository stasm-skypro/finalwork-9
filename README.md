## Проект 5. Трекер привычек

Проект представляет собой приложение для трекера привычек.

Суть методики приобретения полезных привычек описана [**тут**](https://www.google.com/amp/s/lifehacker.ru/pravilo-dvux-minut/amp/).

Приложение позволяет отслеживать полезные привычки для зарегистрированного пользователя и напоминать о них за 15 минут.

## CRUD привычек текущего пользователя

### Эндпоинты:

```GET /habits/ — список привычек текущего пользователя (с пагинацией)```

```POST /habits/ — создание```

```GET /habits/{id}/ — просмотр```

```PUT /habits/{id}/ — полное обновление```

```PATCH /habits/{id}/ — частичное обновление```

```DELETE /habits/{id}/ — удаление```



## Запуск проекта

1. Зарегистрировать нового пользователя по адресу http://127.0.0.1:8000/user/register/
2. Авторизоваться по адресу http://127.0.0.1:8000/user/login/
3. Создать привычку по адресу http://127.0.0.1:8000/habits/

Выполнить команду в Postman:
```POST http://127.0.0.1:8000/habits/```
```json
{
  "user": 2,
      "place": "Баня",
      "time": "07:10:00",
      "action": "Холодная купель",
      "is_pleasant": false,
      "related_habit": 8,
      "periodicity": 2,
      "reward": "",
      "duration": "00:02:00",
      "is_public": false
}
```

Или в терминале:

```bash
curl -X POST http://127.0.0.1:8000/habit/habits/ \
     -H "Authorization: Bearer <твой_access_token>" \
     -H "Content-Type: application/json" \
     -d '{"place": "Баня", "time": "07:10:00", "action": "Холодная купель", "is_pleasant": false, "related_habit": 8, "periodicity": 2, "reward": "", "duration": "00:02:00", "is_public": false}'
```

Для напоминания о полезной привычке создана интеграция с приложением [**Telegram**](https://t.me/stasm226_habit_bot).

В терминале запускаем Redis и Celery:

```bash
redis-server
```
![Запуск Redis](/media/readme/1.png)

```bash
celery -A config worker -l info
```
![Запуск Celery](/media/readme/2.png)

Создана тестовая задача, которая при успешном запуске выводит сообщение в консоль: "Задача работает!"

![Запуск Celery Beat](/media/readme/3.png)


## Права доступа

 Зарегистрированному и авторизованному пользователю доступны все эндпоинты CRUD-операций со своими привычками. А также просмотр публичных привычек всех пользователей без возможности их редактирования и удаления.

## Тесты

Для CRUD операций с привычками и написаны тесты. Также тесты написаны для операций регситрации и авторизации пользователя.
Тестами покрыто 86% кода.


## Документирование

Документация доступна по адресу http://127.0.0.1:8000/swagger/ и http://127.0.0.1:8000/redoc/


## Исправления:

1. Добавил в .env:
	-- CORS_ALLOWED_ORIGINS и CSRF_TRUSTED_ORIGINS, хотя эти переменные прячут толко при реальном деплое, а у нас учебный проект и деплой не планировался.
	-- ACCESS_TOKEN_LIFETIME и REFRESH_TOKEN_LIFETIME, хотя мне до конца непонятно, зачем прятать эти параметры, хотя я нашёл такую рекомендацию.
Добавил **env_template**.
2. Модель привычки содержит все 10 обозначенных в ТЗ полей + ещё поле created_at я добавил для будущего логгирования. Приятные привычки я вынес в отдельную модель. Можно было этого не делать и поле related_habit описать, как форинкей на 'self'.  Но я решил сделать отдельную модель. В этом случае вообще можно было отказаться от валидаторов при создании привычки, так в случае с отдельными моделями полезная и приятная привычки никак не пересекутся.
3. Поле время на выполнение указано, как DurationField. Я посчитал, что такой тип хранения даных для длительности более уместен, так как в БД хранится как INTERVAL, а не TIME. Я бы не хотел менять. Мой выбор обоснован.
4. Эндпоинт для обновления access токена реализован:
urlpatterns = [
path("login/", TokenObtainPairView.as_view(), name="login"),  # Переименуем token/ в login/ для удобства
]
Так как используется стоковый контроллер TokenObtainPairView, то нет необходимости отдельно писать ручку. Я исправил ручку регистрации. Теперь в сваггере можно затестить регистрацию пользователя, запустить  user/ogin/ и получить токен. Я посмотрел в DBear - при регистрации пароль хэшируется.
5. Добавил докстринги для тестов.
